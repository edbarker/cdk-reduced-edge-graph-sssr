Notes for development of reduced edge graph sssr

Here are some initial notes and thoughts. 

In general the approach is in two stages and due to the nature of most typical drug-like molecules (the kind I'm interested in) most (96%) can be solved in stage one. This is because it favours molecules with either single rings separated by acyclic chains and/or simple ring systems - arranged linearly.

I call the approach the reduced edge graph because it is a reduced graph and also an edge graph. That is nodes in the graph represent multiple nodes in the original chemical graph, and an edge graph because the edges in the graph are actually nodes in the original graph. 

There are two stages.

Stage one

1. All terminal branches are pruned away leaving just the rings and their acyclic connectors.
2. An edge is selected to be cut. The selection of this edge is based on finding the least connected atom using a connectivity index described by zamora. This step improves the chances of solving the molecule in stage one, and gives an improvement in efficiency.
3. When the edge is cut all terminal branches are deleted and the entire substructure that has been removed is reconnected as it was in the original graph and represented as a single node which is added to the reduced edge graph.
4. Steps 2 and 3 continue until nothing remains of the molecule.
5. The nodes in the reduced edge graph are connected by finding those atoms shared between neighbouring nodes.
6. Nodes which contain cycles are identified and the cycles retrieved.
7. If there are still rings left to be found then all fragments which are linear are analysed. If the terminal atoms of these linear fragments are found in a single neighbouring fragment then a ring is created. This is made up of the linear fragment plus the shortest path between the atoms in the neighbouring fragment. If a linear fragment gives rise to a ring then it is labelled as solved. This stops it from being considered later. It is a feature of this that all cycles not found at step 6 must have a linear fragment associated with it. However not all linear fragments give rise to cycles.
8. Because it is possible for a fragment containing a ring to be divided by step 7 to create two new smaller rings this ring splitting is tested. To do this when a cycle is found it is compared with all cycles previously found which are larger than it. If it shares any bonds then we find all bonds in common and all bonds exclusive to the new cycle. If the number of bonds exclusive to the new cycle is less than the number in common then splitting occurs. The larger cycle is split by removing the new ring and adding what's left to the linear fragment. It is also necessary to test the rings found against those previously found to check they are unique. If not then they are discarded.
9. If all rings have not been found then steps 7 and 8 are repeated until all linear fragments have been tested.


This shows a typical fragmentation for stage 1:
 
o-o-o-o     o-o-o
    | |     | | |
    o-o-o-o-o-o-o-o		Chemical graph

 
    o-o     o-o-o
    | |     | | |
    o-o-o-o-o-o-o		After deleting terminal branches

 
    o-o     o-o-o
      |     | | |
    o-o-o-o-o-o-o		Bond is cut

 
            o-o-o					o-o
            | | |					| |
            o-o-o		Fragment removed = A    o-o-o-o-o-


            o-o-o
              | |
	    o-o-o		Bond is cut 

 
              o-o					o-o-
              | |					| 
              o-o		Fragment removed = B    o-o-

              o-o
              | 
	      o-o		Bond is cut 

                 					o-o
                 					| |
                 		Fragment removed = C    o-o


Fragments A and C are easily resolved into cycles. Fragment B is resolved by finding shortest path between connectors in Fragment C. 


Stage two

1. Any reduced edge graph arriving here must be cyclic. So to solve these we need to find the shortest path between the terminal atoms of an unsolved linear fragment. This is done by deleting the linear fragment from the molecule, then finding the shortest path between the terminal atoms in what is left.
2. Any ring found in this way is checked for splitting. However, in this stage the cycle being tested can be tested against rings smaller than it - which is not the case in stage one. Found rings are also tested for uniqueness.
3. Steps 1 and 2 are repeated for all unsolved linear fragments.
4. If the rings are still not found then steps 1 and 2 are repeated, but this time if the shortest path does not give rise to a ring then any alternative shortest paths of the same size as the first are sought. This is done by deleting each shortest path after testing.
5. If the rings are still not found then we have to repeat step 4, but with all possible paths between the terminal atoms, in increasing order of size until a new unique ring is found. [not currently implemented]

In theory all rings should be found by now, - that is in the NCI dataset at least. I am assuming that there is nothing out there which fails this - which is a big assumption. Interestingly only one molecule reaches step 5 of stage 2. Everything else is solved.

It is worth pointing out a strange phenomenon with sssr finding which caused some problems. It is also shown up when I tested the rings found by the above method and with the sssrfinder of cdk. It is possible that in some cases where a cycle can revolve around a symmetrical axis that two possible rings exist but only one can be chosen and this choice is arbitrary. Thus my method finds one way and the cdk sssr finds the other but although it finds different rings both are valid. For example consider a benzene ring with a neigbouring ring made by joining an atom [7] to atoms [1] and [4] of the benzene. The extra ring has two possibilities: 
[1][7][4][2][3] or [1][7][4][5][6]. Both are valid. So in stage two the sssr finder fails to find a cycle in the reduced edge graph because they are looking at the rings differently, so cannot resolve all rings. I hope that make sense - it's my theory anyway, I may be wrong.

I did a time trial using the NCI dataset of 250251 molecules in smiles format. Times shown are times taken less the time taken to do the background processing of reading in the smiles (1002s).

CDK SSSRFinder alone 				- 1379s - 1002s = 377s = 663 molecules processed per second.
New algorithm					- 1202s - 1002s = 200s = 1251 mols/s

So clearly the new method is twice as fast when combined with sssrfinder. 

The part that slows things down is where checking for splitting occurs. It might be possible to optimise this step.

Also the extra time taken to find the least connected atom is worth it as more molecules are solved at stage 1. With this step 239865 molecules are solved at stage 1 (amazingly this is 95.8%! of the dataset, with only 10486 unsolved) whereas without this step only 219757 molecules are solved in stage 1 (30594 unsolved).

So things I need to do:

Algorithm Fixes


- look at ways to optimise checksplittingcomplex somehow. 

- how to find all the paths between two atoms

- There is a real problem caused by deleting atoms when stripmolecule/stripterminalatoms deletes atoms from mol. This shifts atoms up the atomcontainer and so i have to pass a copy of the original molecule around as a reference to find original positions. There must be a better way of doing this. Maybe don't delete atoms - just bonds from the molecule.

- is it a unique way of finding the sssr? Has anyone ever done this before? I have no access to papers so can't find out. Last time I looked (6 months ago) I couldn't find anything. Be good if someone could confirm this.


CDK problems

- I have to give each atom an id so that I keep track of them when the atoms are deleted. Otherwise causes problems as everything is shifted out of position. Is there a better way to do this? Maybe not deleting atoms from the molecule would keep everything inplace - just delete the bonds.

- CDK does not recognise elements with mass > 100 - I must need to set something up. Anyone able to tell me what it is I'm not doing. I had to set up an NCI dataset by hand by replacing these atoms. Fortunately not many of them.

- data structure to add info to the atoms, for example the connectivity index for each atom. Does cdk have the option to add a user defined field to the atom such as atom.connectivity? Otherwise I will have to add a separate array which seems clumsy.

- Is there a better way to find atoms on the periphery of a molecule? Connectivity index does not always do this. If could guarantee finding a peripheral atom then can increase efficiency - but it must be a fast calculation. I had used a similar algorithm to the one implemented which is used in canonical enumeration of atoms - I forget its name (marshall?). This needed a few iterations to find least connected atoms so wasn't used as deemed too inefficient - but perhaps i could test this. 


