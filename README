Notes for development of reduced edge graph sssr

Here are some initial notes and thoughts. If things don't make sense let me know. There's a paper in early stages if required. I can send this to anyone interested. 

In general the approach is in two stages and due to the nature of most typical drug-like molecules (the kind I'm interested in) most (96%) can be solved in stage one. This is because it favours molecules with either single rings separated by acyclic chains and/or simple ring systems - arranged linearly.

I call the approach the reduced edge graph because it is a reduced graph and also an edge graph. That is nodes in the graph represent multiple nodes in the original chemical graph, and an edge graph because the edges in the graph are actually nodes in the original graph [references available from me if you want to know more]. 

There are two stages.

Stage one

1. All terminal branches are pruned away leaving just the rings and their acyclic connectors.
2. An edge is selected to be cut. The selection of this edge is based on finding the least connected atom using a connectivity index described by zamora. This step improves the chances of solving the molecule in stage one, and gives an improvement in efficiency.
3. When the edge is cut all terminal branches are deleted and the entire substructure that has been removed is reconnected as it was in the original graph and represented as a single node which is added to the reduced edge graph.
4. Steps 2 and 3 continue until nothing remains of the molecule.
5. The nodes in the reduced edge graph are connected by finding those atoms shared between neighbouring nodes.
6. Nodes which contain cycles are identified and the cycles retrieved.
7. If there are still rings left to be found then all fragments which are linear are analysed. If the terminal atoms of these linear fragments are found in a single neighbouring fragment then a ring is created. This is made up of the linear fragment plus the shortest path between the atoms in the neighbouring fragment.
8. Because it is possible for a fragment containing a ring to be divided by step 7 to create two new smaller rings this ring splitting is tested. To do this the shortest path found in step 7 is compared with the path between the connecting atoms in the linear fragment and if the shortest path is greater then the fragment is split by removing the new ring and adding what's left to the linear fragment. It is also necessary to test the rings found against those previously found to check they are unique. If not then they are discarded.
9. If all rings have not been found then steps 7 and 8 are repeated until all linear fragments have been tested.


This shows a typical fragmentation for stage 1:
 
o-o-o-o     o-o-o
    | |     | | |
    o-o-o-o-o-o-o-o		Chemical graph

 
    o-o     o-o-o
    | |     | | |
    o-o-o-o-o-o-o		After deleting terminal branches

 
    o-o     o-o-o
      |     | | |
    o-o-o-o-o-o-o		Bond is cut

 
            o-o-o					o-o
            | | |					| |
            o-o-o		Fragment removed = A    o-o-o-o-o-


            o-o-o
              | |
	    o-o-o		Bond is cut 

 
              o-o					o-o-
              | |					| 
              o-o		Fragment removed = B    o-o-

              o-o
              | 
	      o-o		Bond is cut 

                 					o-o
                 					| |
                 		Fragment removed = C    o-o


Fragments A and C are easily resolved into cycles. Fragment B is resolved by finding shortest path between connectors in Fragment C. 


Stage two

1. Any reduced edge graph arriving here must be cyclic. So using any sssr algorithm these rings are found.
2. Each cycle found is analysed and the nodes making up the cycle are identified. The fragments represented by these fragments are reconnected. The shortest path through these fragments is traced and used to build a new ring.
3. Ring splitting is tested as in step 8 above, as is unique cycle checking.
4. Repeat steps 2 and 3 until all rings in the reduced edge graph have been analysed, or all rings have been found in the original graph.

In theory all rings should be found by now, but in reality this is not happening. I think this is because of a strange phenomenon with sssr finding. It is also shown up when I tested the rings found by the above method and with the sssrfinder of cdk. It is possible that in some cases where a cycle can revolve around a symmetrical axis that two possible rings exist but only one can be chosen and this choice is arbitrary. Thus my method finds one way and the cdk sssr finds the other but although it finds different rings both are valid. For example consider a benzene ring with a neigbouring ring made by joining an atom [7] to atoms [1] and [4] of the benzene. The extra ring has two possibilities: 
[1][7][4][2][3] or [1][7][4][5][6]. Both are valid. So in stage two the sssr finder fails to find a cycle in the reduced edge graph because they are looking at the rings differently, so cannot resolve all rings. I hope that make sense - it's my theory anyway, I may be wrong.

I did a time trial using the NCI dataset of 250251 molecules in smiles format. Times shown are times taken less the time taken to do the background processing of reading in the smiles (1002s).

CDK SSSRFinder alone 				- 1379s - 1002s = 377s = 663 molecules processed per second.
Stage One plus CDK SSSRFinder			- 1215s - 1002s = 213s = 1174 mols/s
Stage One and Stage tow plus CDKSSSRFinder	- 1242s - 1002s = 240s = 1042 mols/s
Stage One plus CDK SSSRFinder - random bond cut	- 1243s - 1002s = 241s = 1042 mols/s

So clearly stage one is faster when combined with sssrfinder. stage one and stage two are also fast, but stage two is clearly slower than using sssr on the unsolved molecules. I believe there is scope for improving this stage so that it will be faster than sssrfinder here. Also the extra time taken to find the least connected atom is worth it as more molecules are solved at stage 1. With this step 239865 molecules are solved at stage 1 (amazingly this is 95.8%! of the dataset, with only 10486 unsolved) whereas without this step only 219757 molecules are solved in stage 1 (30594 unsolved).

However, I believe finding the least connected atom could easily be made faster by using updated arrays instead of calculating it each time. Also stage two could be speeded up by not going to sssrfinder if only one ring exists (and the greatest number of cyclic reduced edge graphs only have 1 ring). There are other steps here which I'm sure are N^2 but could be made quicker. When I wrote my C version I implemented a simple triangle finding algorithm and this solved a large proportion of the cyclic reduced edge graphs - I'm not sure if this is quicker than sssrfinder. But most cycles are three-membered rings in these reduced edge graphs.

Other ideas I have to improve speed include:
- testing to see if the molecule contains complex ring systems and just go straight to sssr finder - but I'm not sure if there is any suitable index out there which will do this.
- taking advantage of two properties of the technique it might be possible to do everything in stage one. These properties are: that the last fragment found is always a ring; and that there is not one reduced edge graph produced but generally a multitude of possibilities. So if a molecule is unsolved it could be fragmented again with the fragmentation being directed in such a way that the last fragment is always an unknown ring. I have attempted to do this and it does work but there are some molecules which just will not resolve themselves. This would be very fast if it could be done. It would only need to be repeated in the worst case as many times as there are rings left to find.

Wish List

Here is a list of things I think would help improve the algorithm, but I'm not sure how to do them with java or cdk

CDK problems

- I have to give each atom an id so that I keep track of them when the atoms are deleted. Otherwise causes problems as everything is shifted out of position. Is there a better way to do this? Maybe not deleting atoms from the molecule would keep everything inplace - just delete the bonds.
- CDK does not recognise elements with mass > 100 - I must need to set something up. Anyone able to tell me what it is I'm not doing. I had to set up an NCI dataset by hand by replacing these atoms. Fortunately not many of them.


Stage one 

- [FIXED THIS] speed up connectivity by avoiding recalculation at each step - calculate once then when atom is deleted update the connectivity indices of its neighbouring atoms.

- data structure to add info to the atoms, for example the connectivity index for each atom. Does cdk have the option to add a user defined field to the atom such as atom.connectivity? Otherwise I will have to add a separate array which seems clumsy.

- Is there a better way to find atoms on the periphery of a molecule? Connectivity index does not always do this. If could guarantee finding a peripheral atom then can increase efficiency - but it must be a fast calculation. I had used a similar algorithm to the one implemented which is used in canonical enumeration of atoms - I forget its name (marshall?). This needed a few iterations to find least connected atoms so wasn't used as deemed too inefficient - but perhaps i could test this. 

- [TESTED THIS and x64 finds 232399 mols so is not as good. Think this is because it is a way to find the most connected not least connected] Is the zamora calculation as I've implemented it correct? Not sure I've done this right (although it certainly improves performance) so if someone could check this it would be good.

- [FIXED THIS] countatomsincommon - there were two versions of this for some reason - an old slower one and a newer optimised one using an array of atoms and their fragment membership. Could be optimised more maybe - better lookup table?

- checksplittingcomplex could be improved by using some array of ring membership I think. This is not going to be easy to do. 

- [FIXED THIS - but some mols lost from stage one for some reason so needs debugging] maybe checkunique cycles could also be optimised with a lookup array.

- [FIXED THIS -] in resolveeasycycles we need to find linkers but we are repeating ourselves as this was info found when fragments were constructed. Easy way to optimise would be to keep a record of the terminal atoms for each fragment. Again could we not make a field in the atom to keep this info in? Otherwise we need a separate array.

- [not worth changing as linked to checkbranching which is rarely visited] checklinkers - again some lookup table to see if atom still in the fragment may speed this up

- [DONE THIS - but rarely ever goes to this function] checkbranching - easiest way to do this is to label the node an element type if it is a branching node (type III) which can be done during fragmentation

- There is a real problem caused by deleting atoms when stripmolecule/stripterminalatoms deletes atoms from mol. This shifts atoms up the atomcontainer and so i have to pass a copy of the original molecule around as a reference to find original positions. There must be a better way of doing this. Maybe don't delete atoms - just bonds from the molecule.

Stage two

- if only one cycle in fraggraph then don't bother doing sssr - waste of time. just trim it and send the whole thing to resolvecomplexcycles

- also in my C version I couldn't implement sssr as I couldn't find any code and unable to transcribe the papers. So i used a simple triangle finding algorithm - ie for node i find if neighbour of its neighbour of its neighbour is itself. Is this faster than sssr? If so then a lot of reduced edge graphs have 3-membered rings and so could be solved quicker here.

- when making the connections it goes through all atoms but I have a feeling some sort of optimisation is possible here where could have made some array can be looked up that shows which fragments are neighbours - perhaps when going through the linear fragments at the last step of stage one. But then this will miss spiro joined rings. Sure this can be optimised somehow.
 
- explore exactly why some rings cannot be solved at end of stage two.

- resolvecomplexcycles - this is the heart of the problem with stage two i think. in my C version I would find the linear node in the cycle and use this as the starting point. Then find linking atoms to neighbour A. Then find link from neighbour A to its other neighbour (not the starting fragment) then find the shortest path through A. Repeat this for that neighbour until reach starting fragment. then we will have our ring. Just throwing everything together and then using sssr again to find if any unique cycles exist is just lazy, but the only way I could get it to work. This is what needs optimising. 

- implement the idea whereby if stage one is not succesful repeat it but direct the fragmentation to always end on an unfound ring. i have done this in my C version but it didn't always work - it did however find more at stage one. As I think stage one is almost linear repeating it will not make a big difference in time taken

- can anyone show what the time complexity of stage one is? not sure how to do this. ditto stage two - in current state. I think stage one in its optimised state is approaching O(n).

- is it a unique way of finding the sssr? Has anyone ever done this before? I have no access to papers so can't find out. Last time I looked (6 months ago) I couldn't find anything. Be good if someone could confirm this.

